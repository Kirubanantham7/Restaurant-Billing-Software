Item,Quantity,Price,Total
Burger,2,120.0,240.0
Pizza,1,250.0,250.0

Subtotal,490.0
Discount,60.0
Tax,90.0
Final Total,520.0   



üîç Search bar for filtering menu items

üßæ Invoice number formatting (e.g., ORD-2025-0001)

üìä Sales report dashboard by day/week/month

üì¶ Inventory tracking (auto-update stock)

üåê Multi-language support

üîÅ Repeat previous order button

üîê Admin login system (password-protected settings)




tk.Button(right_frame, text="Report History", command=open_report_history, bg="#f2f2f2").pack(fill='x', padx=10, pady=5)


def open_report_history():
    win = tk.Toplevel(root)
    win.title("üìä Report History")
    win.geometry("700x400")

    tk.Label(win, text="Report History", font=("Arial", 16, "bold")).pack(pady=10)

    # Treeview setup
    cols = ("generated_on", "period", "total_orders", "total_sales", "total_tax")
    tree = ttk.Treeview(win, columns=cols, show="headings")
    for col in cols:
        tree.heading(col, text=col.replace("_", " ").title())
        tree.column(col, width=100 if col != "generated_on" else 180)

    tree.pack(expand=True, fill='both', padx=10, pady=10)

    # Load data from database
    conn = sqlite3.connect("restaurant.db")
    cursor = conn.cursor()
    cursor.execute("SELECT generated_on, period, total_orders, total_sales, total_tax FROM reports ORDER BY id DESC")
    rows = cursor.fetchall()
    conn.close()

    for row in rows:
        tree.insert("", "end", values=row)

    # Export to CSV function
    def export_to_csv():
        filename = "report_history.csv"
        with open(filename, "w", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(["Generated On", "Period", "Total Orders", "Total Sales", "Total Tax"])
            for row in rows:
                writer.writerow(row)
        messagebox.showinfo("Exported", f"Saved as {filename}")

    tk.Button(win, text="Export to CSV", command=export_to_csv, bg="#d9edf7").pack(pady=5)

---------------------------------------------------------------------------------------------------------------------------------------------------------------------


import tkinter as tk
from tkinter import ttk, messagebox
from PIL import Image, ImageTk
import sqlite3
import os
import webbrowser
from datetime import datetime
from billing import generate_pdf_bill  # your existing module

# --- Create a Login Window in ---

# Create main root window first
root = tk.Tk()
root.withdraw()  # Hide initially until login is successful
root.title("Kiruba Restaurant Billing System")
root.geometry("800x600")  # Optional: set size for main window

def show_login():
    login_win = tk.Toplevel()
    login_win.title("üîê Login")
    login_win.geometry("300x250")
    login_win.grab_set()  # Keeps focus on login window

    tk.Label(login_win, text="Login", font=("Arial", 16, "bold")).pack(pady=10)

    tk.Label(login_win, text="Username").pack()
    username_entry = tk.Entry(login_win)
    username_entry.pack(pady=5)

    tk.Label(login_win, text="Password").pack()
    password_entry = tk.Entry(login_win, show="*")
    password_entry.pack(pady=5)

    role_var = tk.StringVar(value="cashier")
    tk.Label(login_win, text="Role").pack()
    ttk.Combobox(login_win, textvariable=role_var, values=["admin", "cashier"]).pack(pady=5)

    def do_login():
        username = username_entry.get()
        password = password_entry.get()
        role = role_var.get()

        conn = sqlite3.connect("restaurant.db")
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM users WHERE username = ? AND password = ? AND role = ?", (username, password, role))
        user = cursor.fetchone()
        conn.close()

        if user:
            messagebox.showinfo("Success", f"Welcome {role.capitalize()}!")
            login_win.destroy()  # Close login window
            root.deiconify()     # Show main window
        else:
            messagebox.showerror("Login Failed", "Invalid credentials")

    tk.Button(login_win, text="Login", command=do_login, bg="#d9edf7").pack(pady=10)

# Start the login window first
show_login()

# Start the main event loop
root.mainloop()

# --- Export helpers ---
def export_bill_csv(order_id, items, totals):
    fname = f"bill_order_{order_id}.csv"
    import csv
    with open(fname, 'w', newline='') as f:
        writer = csv.writer(f)
        writer.writerow(['Item', 'Quantity', 'Price', 'Total'])
        for itm in items:
            writer.writerow([itm['name'], itm['quantity'], itm['price'], itm['quantity'] * itm['price']])
        writer.writerow([])
        writer.writerow(['Subtotal', totals['subtotal']])
        writer.writerow(['Discount', totals['discount']])
        writer.writerow(['Tax', totals['tax']])
        writer.writerow(['Final Total', totals['final_total']])
    return fname

def export_bill_json(order_id, items, totals):
    fname = f"bill_order_{order_id}.json"
    import json
    data = {
        'order_id': order_id,
        'date': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        'items': items,
        'totals': totals,
    }
    with open(fname, 'w') as f:
        json.dump(data, f, indent=2)
    return fname

# --- GUI Setup ---
root = tk.Tk()
root.withdraw()     # Hide initially
show_login()        # Will trigger deiconify() after successful login
root.mainloop()     # Main event loop starts here
root.title("Kiruba Restaurant Billing System")

root.geometry("1000x650")
root.config(bg="#f2f2f2")

order_mode = tk.StringVar(value="Dine-In")
payment_method = tk.StringVar(value="Cash")
subtotal_var = tk.StringVar(value="0.00")
total_var = tk.StringVar(value="0.00")

menu_data = []
item_entries = {}
image_refs = []

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
image_folder = os.path.join(BASE_DIR, "images")

# --- Load menu from DB with tax_percent ---
def load_menu():
    global menu_data
    conn = sqlite3.connect("restaurant.db")
    cursor = conn.cursor()
    cursor.execute("SELECT id, name, price, image_path, tax_percent FROM menu_items")
    menu_data = cursor.fetchall()
    conn.close()

# --- Calculate total with per-item tax ---
def calculate_total():
    subtotal = 0.0
    total_tax = 0.0

    for item_id, entry in item_entries.items():
        val = entry.get()
        try:
            qty = int(val) if val else 0
        except ValueError:
            messagebox.showerror("Input Error", f"Invalid quantity '{val}'")
            return

        if qty > 0:
            item = next((i for i in menu_data if i[0] == item_id), None)
            if item:
                price = item[2]
                tax_percent = item[4] or 0  # 4th index is tax_percent
                line_total = qty * price
                subtotal += line_total
                total_tax += (line_total * tax_percent / 100)

    try:
        discount = float(discount_entry.get() or 0)
    except ValueError:
        messagebox.showerror("Input Error", "Enter a valid discount")
        return

    total = subtotal - discount + total_tax

    subtotal_var.set(f"{subtotal:.2f}")
    tax_entry.delete(0, tk.END)
    tax_entry.insert(0, f"{total_tax:.2f}")
    total_var.set(f"{total:.2f}")

# --- Submit order ---
def submit_order():
    calculate_total()
    final = float(total_var.get())
    if final <= 0:
        messagebox.showwarning("Empty Order", "Add items before submitting.")
        return

    conn = sqlite3.connect("restaurant.db")
    cursor = conn.cursor()
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    subtotal = float(subtotal_var.get())
    discount = float(discount_entry.get() or 0)
    tax = float(tax_entry.get() or 0)

    # Insert order record
    cursor.execute("""
        INSERT INTO orders (timestamp, mode, total, discount, tax, final_total)
        VALUES (?, ?, ?, ?, ?, ?)
    """, (timestamp, order_mode.get(), subtotal, discount, tax, final))
    
    order_id = cursor.lastrowid

    # Generate invoice number
    year = datetime.now().year
    invoice_number = f"ORD-{year}-{order_id:04d}"

    # Optional: store invoice number in the database (if column exists)
    try:
        cursor.execute("UPDATE orders SET invoice_number = ? WHERE id = ?", (invoice_number, order_id))
    except sqlite3.OperationalError:
        # Column might not exist ‚Äì silently ignore
        pass

    # Record ordered items
    ordered_items = []
    for item_id, entry in item_entries.items():
        try:
            qty = int(entry.get())
        except:
            continue
        if qty > 0:
            cursor.execute("INSERT INTO order_items (order_id, item_id, quantity) VALUES (?, ?, ?)",
                           (order_id, item_id, qty))
            item = next((i for i in menu_data if i[0] == item_id), None)
            if item:
                ordered_items.append({'name': item[1], 'price': item[2], 'quantity': qty})

    # Record payment
    cursor.execute("INSERT INTO payments (order_id, payment_method, amount_paid) VALUES (?, ?, ?)",
                   (order_id, payment_method.get(), final))

    conn.commit()
    conn.close()

    # Use invoice number in filename
    pdf_path = f"bill_{invoice_number}.pdf"
    totals = {'subtotal': subtotal, 'discount': discount, 'tax': tax, 'final_total': final}

    generate_pdf_bill(invoice_number, ordered_items, totals, pdf_path)
    messagebox.showinfo("Success", f"Bill saved as {pdf_path}")
    display_bill_preview(invoice_number, ordered_items, totals, pdf_path)


# --- Bill preview window ---
def display_bill_preview(invoice_number, items, totals, pdf_path):
    win = tk.Toplevel(root)
    win.title(f"Bill Preview ‚Äî Order {invoice_number}")
    win.geometry("500x600")

    tk.Label(win, text=f"Invoice #: {invoice_number}", font=("Arial",14,"bold")).pack(pady=5)
    tk.Label(win, text=f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M')}").pack()

    text = tk.Text(win, width=60, height=20, font=("Courier New",10))
    text.pack(pady=10)
    for itm in items:
        line = f"{itm['name']:<20} x{itm['quantity']:<3} ‚Çπ{itm['price']:<6} = ‚Çπ{itm['quantity']*itm['price']:.2f}"
        text.insert(tk.END, line + "\n")
    text.insert(tk.END, "\n")
    text.insert(tk.END, f"Subtotal: ‚Çπ{totals['subtotal']:.2f}\n")
    text.insert(tk.END, f"Discount: ‚Çπ{totals['discount']:.2f}\n")
    text.insert(tk.END, f"Tax: ‚Çπ{totals['tax']:.2f}\n")
    text.insert(tk.END, f"Total: ‚Çπ{totals['final_total']:.2f}\n")
    text.config(state="disabled")

    def export_pdf(): messagebox.showinfo("PDF", f"Saved at:\n{os.path.abspath(pdf_path)}")
    def export_csv_btn(): messagebox.showinfo("CSV", f"Saved: {export_bill_csv(invoice_number, items, totals)}")
    def export_json_btn(): messagebox.showinfo("JSON", f"Saved: {export_bill_json(invoice_number, items, totals)}")
    def share_whatsapp():
        abs_path = os.path.abspath(pdf_path)
        if os.path.exists(abs_path):
            webbrowser.open("https://web.whatsapp.com")
            messagebox.showinfo("WhatsApp", f"Attach manually:\n{abs_path}")
        else:
            messagebox.showerror("Error", "PDF not found.")

    btn_frame = tk.Frame(win)
    btn_frame.pack(pady=10)
    tk.Button(btn_frame, text="Export PDF", command=export_pdf).grid(row=0, column=0, padx=5)
    tk.Button(btn_frame, text="Export CSV", command=export_csv_btn).grid(row=0, column=1, padx=5)
    tk.Button(btn_frame, text="Export JSON", command=export_json_btn).grid(row=0, column=2, padx=5)
    tk.Button(btn_frame, text="Share via WhatsApp", command=share_whatsapp).grid(row=1, column=0, columnspan=3, pady=10)

# --- open sales dashboard ---

def open_sales_dashboard():
    from datetime import timedelta

    win = tk.Toplevel(root)
    win.title("üìä Sales Report Dashboard")
    win.geometry("600x600")

    selected_mode = tk.StringVar(value="day")
    sales_data = {}

    def fetch_report(mode):
        nonlocal sales_data
        from collections import defaultdict

        now = datetime.now()
        if mode == "day":
            start = now.replace(hour=0, minute=0, second=0, microsecond=0)
        elif mode == "week":
            start = now - timedelta(days=now.weekday())
            start = start.replace(hour=0, minute=0, second=0, microsecond=0)
        elif mode == "month":
            start = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        else:
            return

        conn = sqlite3.connect("restaurant.db")
        cursor = conn.cursor()

        # Get order totals
        cursor.execute("""
            SELECT COUNT(*), SUM(final_total), SUM(tax)
            FROM orders
            WHERE timestamp >= ?
        """, (start.strftime("%Y-%m-%d %H:%M:%S"),))
        row = cursor.fetchone()
        num_orders = row[0] or 0
        total_sales = row[1] or 0.0
        total_tax = row[2] or 0.0

        # Get most sold items
        cursor.execute("""
            SELECT mi.name, SUM(oi.quantity) as total_qty
            FROM order_items oi
            JOIN orders o ON o.id = oi.order_id
            JOIN menu_items mi ON mi.id = oi.item_id
            WHERE o.timestamp >= ?
            GROUP BY oi.item_id
            ORDER BY total_qty DESC
            LIMIT 5
        """, (start.strftime("%Y-%m-%d %H:%M:%S"),))
        top_items = cursor.fetchall()

        conn.close()
    
        # Store for export
        sales_data = {
            'mode': mode,
            'start': start.strftime("%Y-%m-%d"),
            'orders': num_orders,
            'sales': total_sales,
            'tax': total_tax,
            'top_items': top_items
        }

        # Show in UI
        result_text.config(state="normal")
        result_text.delete(1.0, tk.END)
        result_text.insert(tk.END, f"üïí Period: {mode.capitalize()}\n")
        result_text.insert(tk.END, f"üìÖ From: {sales_data['start']}\n")
        result_text.insert(tk.END, f"üßæ Orders: {num_orders}\n")
        result_text.insert(tk.END, f"üí∞ Total Sales: ‚Çπ{total_sales:.2f}\n")
        result_text.insert(tk.END, f"üßÆ Total Tax: ‚Çπ{total_tax:.2f}\n\n")
        result_text.insert(tk.END, "üîù Most Sold Items:\n")
        for name, qty in top_items:
            result_text.insert(tk.END, f"  - {name} ({qty})\n")
        result_text.config(state="disabled")

    def export_to_csv():
        if not sales_data:
            messagebox.showwarning("No Data", "Generate a report first.")
            return
        filename = f"sales_report_{sales_data['mode']}_{sales_data['start']}.csv"
        with open(filename, 'w', newline='') as f:
            import csv
            writer = csv.writer(f)
            writer.writerow(["Sales Report"])
            writer.writerow(["Period", sales_data['mode'].capitalize()])
            writer.writerow(["Start Date", sales_data['start']])
            writer.writerow(["Total Orders", sales_data['orders']])
            writer.writerow(["Total Sales", sales_data['sales']])
            writer.writerow(["Total Tax", sales_data['tax']])
            writer.writerow([])
            writer.writerow(["Most Sold Items"])
            writer.writerow(["Item", "Quantity"])
            for name, qty in sales_data['top_items']:
                writer.writerow([name, qty])
        messagebox.showinfo("Exported", f"CSV saved as {filename}")

         # Save report to DB
    def fetch_report(mode):
             # ...
        total_sales = ...
        num_orders = ...
        total_tax = ...
        conn = sqlite3.connect("restaurant.db")
        cursor = conn.cursor()
        cursor.execute("""
            INSERT INTO reports (generated_on, period, total_orders, total_sales, total_tax)
            VALUES (?, ?, ?, ?, ?)
        """, (
            datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            mode,
            num_orders,
            total_sales,
            total_tax
        ))
        conn.commit()
        conn.close()
     
       

    # Buttons
    btn_frame = tk.Frame(win)
    btn_frame.pack(pady=10)
    for label in ["day", "week", "month"]:
        tk.Button(btn_frame, text=label.capitalize(),
                  command=lambda m=label: fetch_report(m),
                  width=10).pack(side="left", padx=5)

    result_text = tk.Text(win, width=60, height=20, font=("Courier New", 10))
    result_text.pack(pady=10)
    result_text.config(state="disabled")

    # Export button
    tk.Button(win, text="‚¨á Export to CSV", command=export_to_csv, bg="#99ccff").pack(pady=10)


# --- Layout ---
header = tk.Frame(root, bg="#003366", height=60)
header.pack(fill="x")
tk.Label(header, text="üçΩÔ∏è KIRUBA RESTAURANT", fg="white", bg="#003366", font=("Arial", 20, "bold")).pack(pady=10)

main_frame = tk.Frame(root, bg="#f2f2f2")
main_frame.pack(fill="both", expand=True, padx=10, pady=10)

left_frame = tk.Frame(main_frame, bg="white", bd=2, relief="groove")
left_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0,10))

right_frame = tk.Frame(main_frame, bg="white", bd=2, relief="groove")
right_frame.pack(side=tk.RIGHT, fill=tk.Y)

ttk.Combobox(right_frame, values=["Dine-In", "Takeaway"], textvariable=order_mode).pack(fill='x', padx=10, pady=10)

# --- Scrollable Menu UI ---
# --- Search Bar ---
search_frame = tk.Frame(left_frame, bg="white")
search_frame.pack(fill='x', padx=10, pady=(10,0))

tk.Label(search_frame, text="üîç Search:", bg="white").pack(side="left")
search_var = tk.StringVar()

search_entry = tk.Entry(search_frame, textvariable=search_var)
search_entry.pack(side="left", fill="x", expand=True, padx=5)

def on_search(*args):
    search_term = search_var.get().lower()
    render_menu(search_term)

search_var.trace_add("write", on_search)

def render_menu(search_term=""):
    for widget in menu_items_frame.winfo_children():
        widget.destroy()

    for item_id, name, price, image_path, tax_percent in menu_data:
        if search_term and search_term not in name.lower():
            continue

        frame = tk.Frame(menu_items_frame, bg="white", pady=5)
        frame.pack(fill="x", padx=10, pady=5)

        full_image_path = os.path.join(image_folder, os.path.basename(image_path)) if image_path else None
        if full_image_path and os.path.exists(full_image_path):
            try:
                img = Image.open(full_image_path).convert("RGB").resize((50, 50))
                photo = ImageTk.PhotoImage(img)
                image_refs.append(photo)
                tk.Label(frame, image=photo, bg="white").pack(side="left", padx=5)
            except:
                tk.Label(frame, text="üñºÔ∏è", bg="white", width=5).pack(side="left", padx=5)
        else:
            tk.Label(frame, text="üñºÔ∏è", bg="white", width=5).pack(side="left", padx=5)

        tk.Label(frame, text=f"{name} ‚Äì ‚Çπ{price:.2f}", bg="white", font=("Arial",12)).pack(side="left", padx=5)
        qty_entry = tk.Entry(frame, width=5)
        qty_entry.pack(side="right", padx=5)
        item_entries[item_id] = qty_entry


tk.Label(left_frame, text="Menu", bg="white", font=("Arial",16,"bold")).pack(anchor='w', padx=10, pady=10)
menu_canvas = tk.Canvas(left_frame, bg="white", highlightthickness=0)
menu_scroll = ttk.Scrollbar(left_frame, orient="vertical", command=menu_canvas.yview)
menu_items_frame = tk.Frame(menu_canvas, bg="white")
menu_items_frame.bind("<Configure>", lambda e: menu_canvas.configure(scrollregion=menu_canvas.bbox("all")))
menu_canvas.create_window((0,0), window=menu_items_frame, anchor="nw")
menu_canvas.configure(yscrollcommand=menu_scroll.set)
menu_canvas.pack(side="left", fill="both", expand=True)
menu_scroll.pack(side="right", fill="y")

# --- Load & Display Menu Items ---
load_menu()
for item_id, name, price, image_path, tax_percent in menu_data:
    frame = tk.Frame(menu_items_frame, bg="white", pady=5)
    frame.pack(fill="x", padx=10, pady=5)

    full_image_path = os.path.join(image_folder, os.path.basename(image_path)) if image_path else None
    if full_image_path and os.path.exists(full_image_path):
        try:
            img = Image.open(full_image_path).convert("RGB").resize((50, 50))
            photo = ImageTk.PhotoImage(img)
            image_refs.append(photo)
            tk.Label(frame, image=photo, bg="white").pack(side="left", padx=5)
        except:
            tk.Label(frame, text="üñºÔ∏è", bg="white", width=5).pack(side="left", padx=5)
    else:
        tk.Label(frame, text="üñºÔ∏è", bg="white", width=5).pack(side="left", padx=5)

    tk.Label(frame, text=f"{name} ‚Äì ‚Çπ{price:.2f}", bg="white", font=("Arial",12)).pack(side="left", padx=5)
    qty_entry = tk.Entry(frame, width=5)
    qty_entry.pack(side="right", padx=5)
    item_entries[item_id] = qty_entry

# --- Right Panel Inputs ---
tk.Label(right_frame, text="Discount (‚Çπ):", bg="white", font=('Arial',12)).pack(anchor='w', padx=10, pady=(10,0))
discount_entry = tk.Entry(right_frame)
discount_entry.pack(fill='x', padx=10)

tk.Label(right_frame, text="Tax (‚Çπ):", bg="white", font=('Arial',12)).pack(anchor='w', padx=10, pady=(10,0))
tax_entry = tk.Entry(right_frame)
tax_entry.pack(fill='x', padx=10)

tk.Label(right_frame, text="Subtotal:", bg="white", font=('Arial',12)).pack(anchor='w', padx=10, pady=(20,0))
tk.Label(right_frame, textvariable=subtotal_var, bg="white", font=('Arial',12,"bold")).pack(anchor='w', padx=10)

tk.Label(right_frame, text="Final Total:", bg="white", font=('Arial',12)).pack(anchor='w', padx=10, pady=(10,0))
tk.Label(right_frame, textvariable=total_var, bg="white", font=('Arial',12,"bold")).pack(anchor='w', padx=10)

tk.Label(right_frame, text="Payment Method:", bg="white", font=('Arial',12)).pack(anchor='w', padx=10, pady=(20,0))
ttk.Combobox(right_frame, values=["Cash", "Card", "UPI"], textvariable=payment_method).pack(fill='x', padx=10)

tk.Button(right_frame, text="Calculate Total", command=calculate_total, bg="#cce6ff").pack(fill='x', padx=10, pady=(15,5))
tk.Button(right_frame, text="Submit & Generate Bill", command=submit_order, bg="#004d00", fg="white").pack(fill='x', padx=10)
tk.Button(right_frame, text="View Sales Report", command=open_sales_dashboard, bg="#ffcc00").pack(fill='x', padx=10, pady=10)


root.mainloop()

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

That empty middle space is actually a golden opportunity ‚Äî we can fill it with features that make the restaurant billing app look professional and also make the billing process smoother.

Here are a few practical + professional ideas for that space:

1Ô∏è‚É£ Live Bill Preview (Professional Touch)
Show the bill in a receipt-style layout as items are added.

This gives a real-time preview of how the final bill will look before saving.

Can include:

Restaurant name & logo

List of ordered items

Total amount

Date & time

"Thank you" message

Example:

markdown
Copy
Edit
[Restaurant Logo]
Restaurant Name
-----------------------
Item       Qty   Total
Pizza       2    500
Burger      1    120
-----------------------
Total:           620
Thank You!
2Ô∏è‚É£ Restaurant Logo & Branding
Add your restaurant‚Äôs logo at the top center.

Keep it small but clear ‚Äî it instantly makes the UI look branded.

Could be loaded from a .png file.

3Ô∏è‚É£ Sales Summary (Today‚Äôs Stats)
Show a small dashboard card with:

Number of bills today

Total sales amount

Best selling item of the day

Example:

mathematica
Copy
Edit
Today: 12 bills
Total Sales: ‚Çπ8,450
Top Item: Pizza
4Ô∏è‚É£ Category Quick Buttons
In the free space, place menu category buttons (like Beverages, Main Course, Desserts) so staff can quickly select items without typing names every time.

5Ô∏è‚É£ Decorative Background or Themed Colors
Instead of plain white/gray, add a light patterned background or gradient.

Can make it look like a point-of-sale (POS) system.

6Ô∏è‚É£ Customer Details (Optional for Bill)
Fields for Customer Name, Phone, Table Number.

These can be printed on the bill, making it more professional and traceable.

üí° My suggestion for maximum impact:
Use that middle space for a receipt-style live bill preview on the left and a small sales summary on the right.
This makes the cashier‚Äôs job easier and the UI look like a proper POS billing system.

If you want, I can modify your current code so the middle space becomes a live bill preview with restaurant logo and a summary section ‚Äî that way your bill will also look polished when printed.








You said:
and add this also with your ideas  restarunat dinning tables which how many tables is free or occupied 


ChatGPT said:
Perfect ‚Äî adding a restaurant table occupancy view will make your billing app feel like a true POS + restaurant management system.
We can place it in that empty middle space along with the professional features I suggested earlier.

Here‚Äôs how we can structure the center section:

Pro Layout for Middle Space
Left Side:

Live Receipt Preview (updates as you add items)

Restaurant logo at the top

Customer details (optional)

Right Side:

Table Occupancy View

Show tables as small buttons or colored labels:

Green ‚Üí Free

Red ‚Üí Occupied

Clicking a table marks it as occupied and links it to the current bill.

Today‚Äôs Sales Summary (Bills count, total sales, top item)

Example Table Occupancy View
sql
Copy
Edit
[Table 1] üü¢ Free
[Table 2] üî¥ Occupied
[Table 3] üü¢ Free
[Table 4] üî¥ Occupied
Color codes:

üü¢ Green / "Free" means no bill is open for that table.

üî¥ Red / "Occupied" means there‚Äôs an active bill for that table.

Clicking a table:

If Free ‚Üí start a new bill for that table

If Occupied ‚Üí load the existing bill

How it will work in your code
We‚Äôll create a tables list with their status.

In the UI, we‚Äôll make them appear as clickable buttons in a grid.

When a bill is saved ‚Üí the table is marked as free again.

Optionally, we can store this in the database to persist between sessions.

I can update your current app.py so the middle space has:
‚úÖ Restaurant logo
‚úÖ Live bill preview (receipt-style)
‚úÖ Table occupancy view (free/occupied with click actions)
‚úÖ Sales summary

Do you want me to go ahead and write this full improved version of your code with these upgrades?